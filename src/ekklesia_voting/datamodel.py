import ekklesia_common.ekklesia_auth
from ekklesia_common.database import Base, C, rel, FK, bref
from sqlalchemy import Boolean, DateTime, Integer, func, String, Text, Sequence, JSON
from sqlalchemy.orm import object_session
from sqlalchemy_utils.types import UUIDType


class BallotOption(Base):
    __tablename__ = "ballot_option"
    uuid = C(UUIDType, server_default=func.gen_random_uuid(), primary_key=True)
    ballot_uuid = C(UUIDType, FK("ballot.uuid"), nullable=False)
    title = C(String)
    text = C(Text, nullable=False)

    ballot = rel("Ballot", back_populates="options")
    responses = rel("OptionResponse", back_populates="option")


class Ballot(Base):
    __tablename__ = "ballot"
    uuid = C(UUIDType, server_default=func.gen_random_uuid(), primary_key=True)
    department = C(String, nullable=False)
    title = C(String)
    created_at = C(DateTime, nullable=False, server_default=func.now())
    starts_at = C(DateTime, nullable=False)
    ends_at = C(DateTime, nullable=False)
    use_yes_no: bool = C(Boolean, nullable=False, server_default="true")
    min_points: int = C(Integer, nullable=False, server_default="0")
    max_points: int = C(Integer, nullable=False, server_default="0")
    unique_points: bool = C(Boolean, nullable=False, server_default="false")
    use_rank: bool = C(Boolean, nullable=False, server_default="false")
    description: str = C(Text)

    options = rel(BallotOption, back_populates="ballot")

    def votes_to_confirm(self, voter):
        return (
            object_session(self)
            .query(VerificationToken.token, OptionResponse, BallotOption)
            .filter(
                VerificationToken.voter_id == voter.id,
                OptionResponse.confirmed_at == None,
                VerificationToken.response_uuid == OptionResponse.uuid,
                BallotOption.uuid == OptionResponse.option_uuid,
                BallotOption.ballot == self,
            )
            .order_by(OptionResponse.yes_no.desc(), OptionResponse.points.desc())
        )


class VerificationToken(Base):
    __tablename__ = "verification_token"
    token = C(UUIDType, server_default=func.gen_random_uuid(), primary_key=True)
    response_uuid = C(UUIDType, FK("option_response.uuid"), nullable=False)
    voter_id = C(Integer, FK("voter.id"), nullable=False)

    voter = rel("Voter")
    response = rel("OptionResponse", back_populates="token")


class OptionResponse(Base):
    __tablename__ = "option_response"
    uuid = C(UUIDType, server_default=func.gen_random_uuid(), primary_key=True)
    yes_no = C(Boolean)
    points = C(Integer)
    rank = C(Integer)
    option_uuid = C(UUIDType, FK("ballot_option.uuid"), nullable=False)
    created_at = C(DateTime, nullable=False, server_default=func.now())
    confirmed_at = C(DateTime, nullable=True)

    token = rel(VerificationToken, back_populates="response")
    option = rel(BallotOption, back_populates="responses")


class Voter(Base):
    __tablename__ = "voter"
    id: int = C(Integer, Sequence("id_seq", optional=True), primary_key=True)
    auid: str = C(
        Text,
        unique=True,
        comment=(
            "Application-specific user ID. In OpenID Connect, this is called `sub` "
            "(subject identifier) and is generated by the issuer."
        ),
    )


class OAuthToken(Base, ekklesia_common.ekklesia_auth.OAuthTokenMixin):
    __tablename__ = "oauth_token"
    id = C(Integer, FK("voter.id"), primary_key=True)
    voter = rel(Voter, backref=bref("oauth_token", uselist=False))
